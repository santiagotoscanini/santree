# Santree Shell Integration for Zsh
# ==================================
#
# This script provides a shell wrapper around the santree CLI to enable:
# 1. Automatic directory switching after `create` and `switch` commands
# 2. Automatic recovery when the current worktree directory is deleted
#
# Installation:
#   Add to your .zshrc: eval "$(santree shell-init zsh)"
#
# How it works:
# -------------
# Since child processes cannot change the parent shell's directory, the CLI
# outputs special markers (SANTREE_CD:path) that this wrapper intercepts
# to perform the actual `cd` command in the current shell.
#
# The wrapper also handles the case where you're in a worktree directory
# that gets deleted (e.g., after `santree clean` or `santree remove`),
# automatically returning you to the main repository or home directory.

# Export marker so `santree doctor` can verify shell integration is loaded
export SANTREE_SHELL_INTEGRATION=1

function santree() {
    # -------------------------------------------------------------------------
    # STEP 1: Handle deleted directory recovery
    # -------------------------------------------------------------------------
    if [[ ! -d "$(pwd 2>/dev/null)" ]]; then
        local current_path="$(pwd 2>/dev/null)"

        if [[ "$current_path" == */.santree/worktrees/* ]]; then
            local main_repo="${current_path%%/.santree/worktrees/*}"
            if [[ -d "$main_repo" ]]; then
                echo "⚠ Worktree directory deleted. Returning to main repo."
                cd "$main_repo" || cd ~ || return 1
            else
                cd ~ || return 1
            fi
        else
            echo "⚠ Current directory no longer exists. Returning to home."
            cd ~ || return 1
        fi
    fi

    # -------------------------------------------------------------------------
    # STEP 2: Handle commands that need directory switching
    # -------------------------------------------------------------------------
    if [[ "$1" == "create" || "$1" == "switch" || "$1" == "sw" ]]; then
        local output
        output=$(command santree "$@" 2>&1)
        local exit_code=$?

        if [[ "$output" == *SANTREE_CD:* ]]; then
            echo "$output" | grep -v "SANTREE_CD:" | grep -v "SANTREE_WORK:"

            local target_dir=$(echo "$output" | sed 's/\x1b\[[0-9;]*m//g' | grep "SANTREE_CD:" | sed 's/.*SANTREE_CD://')

            if [[ -n "$target_dir" && -d "$target_dir" ]]; then
                cd "$target_dir" && echo "Switched to: $target_dir"
            fi

            if [[ "$output" == *SANTREE_WORK:* ]]; then
                local work_mode=$(echo "$output" | sed 's/\x1b\[[0-9;]*m//g' | grep "SANTREE_WORK:" | sed 's/.*SANTREE_WORK://')
                [[ "$work_mode" == "plan" ]] && command santree work --plan || command santree work
            fi
        else
            echo "$output"
        fi
        return $exit_code
    fi

    # -------------------------------------------------------------------------
    # STEP 3: Pass through all other commands
    # -------------------------------------------------------------------------
    command santree "$@"
}

# Alias for convenience
alias st='santree'

# Quick create worktree with work+plan+tmux (prompts for branch)
function stw() {
    local branch
    vared -p "Branch name: " branch
    [[ -z "$branch" ]] && echo "Branch name required" && return 1
    santree create "$branch" --work --plan --tmux
}

# =============================================================================
# Zsh Completions (auto-generated)
# =============================================================================

__santree_get_worktree_branches() {
    local -a branches
    branches=(${(f)"$(git worktree list --porcelain 2>/dev/null | grep '^branch ' | sed 's/branch refs\/heads\///')"})
    _describe -t branches 'worktree branches' branches
}

__santree_get_all_branches() {
    local -a branches
    branches=(${(f)"$(git branch -a 2>/dev/null | sed 's/^[* ] //' | sed 's/remotes\/origin\///' | sort -u)"})
    _describe -t branches 'git branches' branches
}

__santree_commands() {
    local -a commands
    commands=(
{%- for cmd in commands %}
        '{{ cmd.name }}:{{ cmd.description }}'
{%- endfor %}
    )
    _describe -t commands 'santree commands' commands
}

{% for cmd in commands %}
__santree_{{ cmd.funcName }}() {
{%- if cmd.options.length == 0 and not cmd.hasArgs %}
    return 0
{%- else %}
    _arguments \
{%- if cmd.argCompletion == 'worktree_branches' %}
        '1:branch:__santree_get_worktree_branches'{% if cmd.options.length > 0 %} \{% endif %}
{%- elif cmd.argCompletion == 'shells' %}
        '1:shell:(zsh bash)'{% if cmd.options.length > 0 %} \{% endif %}
{%- elif cmd.hasArgs %}
        '1:branch name:'{% if cmd.options.length > 0 %} \{% endif %}
{%- endif %}
{%- for opt in cmd.options %}
        '--{{ opt.name }}[{{ opt.description }}]{% if opt.completion == 'all_branches' %}:base branch:__santree_get_all_branches{% endif %}'{% if not loop.last %} \{% endif %}
{%- endfor %}
{%- endif %}
}

{% endfor %}
_santree() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    _arguments -C \
        '1: :->command' \
        '*:: :->args'

    case $state in
        command)
            __santree_commands
            ;;
        args)
            case $line[1] in
{%- for cmd in commands %}
                {{ cmd.name }})
                    __santree_{{ cmd.funcName }}
                    ;;
{%- endfor %}
            esac
            ;;
    esac
}

# Register completions (only if compdef is available)
if (( $+functions[compdef] )); then
    compdef _santree santree
    compdef _santree st
fi
